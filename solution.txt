Ex00

# Criar link simbolico
ln -s test0 test6

hard links nos arquivos test3 e test5 ??

# Comandos truncate
truncate -s 4 test1
truncate -s 1 test3
truncate -s 2 test4
truncate -s 1 test5

# Ajustando as datas e horas dos arquivos
touch -t 06012047 test0
touch -t 06012146 test1
touch -t 06012245 test2
touch -t 06012344 test3
touch -t 06012343 test4
touch -t 06012344 test5
touch -h -t 06012220 test6

# Comandos chmod
chmod 715 test0
chmod 714 test1
chmod 504 test2
chmod 404 test3
chmod 641 test4
chmod 404 test5
chmod 755 test6


Ex01
echo -e "Z\n" > z


Ex02
ex08
find . \( -name "*~" -o -name "#*#" \) -type f -print -delete
encontra tudo que tem no dir atual
que tenha nome ~ e #
pega so files
mostra
deleta

Ex03
#!/bin/sh
find -type f -name "*sh" -exec basename{} .sh\;
find pesquisa a partir do diretorio atual
-type f restringe a busca a apenas arquivos
-exec é uma opção do comando find que permite executar um comando em cada arquivo encontrado que corresponda aos critérios de busca
basename remover a extensão .sh
\; indica ao find que o exec terminou

Ex04
#!/bin/sh
ifconfig | grep ether | cut -d ' ' -f10
ifconfig: Exibe as configurações das interfaces de rede na sua máquina, incluindo os endereços MAC.

grep ether: Filtra a saída do ifconfig para mostrar apenas as linhas que contêm a palavra ether, que é onde o ifconfig geralmente exibe o endereço MAC.

    cut: Comando usado para dividir a saída em partes.
    -d ' ': Define o delimitador como um espaço (' '), dividindo a linha em campos.
    -f10: Seleciona o décimo campo, que é onde o endereço MAC está localizado na linha resultante.
    
Ex05
antes de " \ $ precisa de uma \ para entender como literal
echo "42" > "...." 
Truncate -s 2 *waM*

________________________________________________________________

Ex24

# Criação de arquivos objeto
OBJ_FILES = $(SRCS:.c=.o)
# OBJ_FILES: Esta variável armazena os arquivos objeto que serão gerados a partir dos arquivos fonte. Os arquivos objeto são os resultados da compilação dos arquivos .c, e eles têm a extensão .o.
# $(SRCS:.c=.o): Esta é uma forma de substituição de sufixo em Makefile. O que acontece aqui é que para cada arquivo listado na variável SRCS, o sufixo .c é substituído por .o.


# Regra Padrão para Criar a Biblioteca
all: $(NAME) 
# Esta regra será executada quando você chamar `make`. 
# O alvo é a biblioteca definida pela variável `NAME` (libft.a).

$(NAME): $(OBJ_FILES) 
# Aqui definimos que a biblioteca `$(NAME)` (libft.a) depende dos arquivos objeto `$(OBJ_FILES)`.
# A biblioteca só será criada se todos os arquivos objeto estiverem disponíveis e atualizados.

	@ar rcs $@ $^ 
	# O comando `ar` é usado para criar a biblioteca estática.
	# `rcs` são opções que significam:
	# r: Insere arquivos na biblioteca.
	# c: Cria a biblioteca se não existir.
	# s: Indexa a biblioteca para facilitar a ligação.
	# `$@` refere-se ao alvo (libft.a), enquanto `$^` refere-se a todos os pré-requisitos (arquivos objeto).

# Regra para criar arquivos objeto a partir de arquivos fonte
%.o: %.c 
# Esta é uma regra de padrão. Ela diz que para cada arquivo .o, 
# o Makefile deve usar o arquivo .c correspondente para gerar o arquivo objeto.

	$(CC) $(CFLAGS) -I$(INCS_DIR) -c $< -o $@ 
# $(CC): Refere-se ao compilador que você definiu anteriormente (neste caso, gcc).
# $(CFLAGS): Refere-se às opções de compilação que você definiu (por exemplo, -Wall -Wextra -Werror).
# -I$(INCS_DIR): Adiciona o diretório de cabeçalhos (includes) ao caminho de busca do compilador.
# -c: Diz ao compilador para compilar o arquivo .c em um arquivo objeto, sem criar um executável.
# $<: Refere-se ao primeiro pré-requisito da regra, que é o arquivo fonte correspondente ao arquivo objeto.
# -o $@: Define o nome do arquivo de saída como o alvo da regra, que neste caso é o arquivo objeto (%.o).

# Regra para limpar arquivos objeto
clean: 
	@rm -f $(OBJ_FILES) 
# clean:: Esta é uma regra chamada ao usar make clean. É uma convenção comum em Makefiles para limpar os arquivos gerados.
# @rm -f $(OBJ_FILES): Este comando remove todos os arquivos objeto gerados durante a compilação.
# -f: Força a remoção dos arquivos sem solicitar confirmação, e ignora arquivos que não existem.

# Regra para limpar arquivos objeto e a biblioteca
fclean: clean 
# fclean:: Esta é uma regra chamada ao usar make fclean. Ela é uma versão "forçada" da regra clean.
# clean: Chama a regra clean para remover os arquivos objeto.
# @rm -f $(NAME): Remove a biblioteca (libft.a) gerada.

# Regra para recompilar a biblioteca
re: fclean all 
# re:: Esta é uma regra que permite recompilar a biblioteca.
# fclean: Chama a regra fclean para garantir que todos os arquivos sejam removidos antes da recompilação.
# all: Depois de limpar, chama a regra all, que cria a biblioteca novamente.